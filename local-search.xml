<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mysql数据库的备份与恢复</title>
    <link href="/2024/11/06/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <url>/2024/11/06/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql数据库的备份与恢复"><a href="#Mysql数据库的备份与恢复" class="headerlink" title="Mysql数据库的备份与恢复"></a>Mysql数据库的备份与恢复</h1><p>本篇文章介绍如何用DokcerFile构建容器数据库，并且在程序中使用该数据库。还介绍如何对mysql数据库进行备份与恢复。</p><h2 id="DockerFile构建数据库容器"><a href="#DockerFile构建数据库容器" class="headerlink" title="DockerFile构建数据库容器"></a>DockerFile构建数据库容器</h2><p>本节介绍如何用DockerFile构建数据库容器。</p><h3 id="配置my-cnf"><a href="#配置my-cnf" class="headerlink" title="配置my.cnf"></a>配置my.cnf</h3><p>my.cnf文件是数据库的配置文件。<br><br>其中<code>[mysqld]</code>表示mysql服务端的配置。<code>[client]</code>表示mysql客户端的配置。<br></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-comment"># 设置MySQL服务器的数据目录</span><br><span class="hljs-comment"># datadir=/var/lib/mysql</span><br><br><span class="hljs-comment"># 设置MySQL服务器监听的IP地址</span><br><span class="hljs-comment"># bind-address=127.0.0.1</span><br><br><span class="hljs-comment"># 设置MySQL服务器的端口号</span><br><span class="hljs-attr">port</span>=<span class="hljs-number">3306</span><br><br><span class="hljs-comment"># 设置MySQL服务器的字符集</span><br><span class="hljs-attr">character-set-server</span>=utf8<br><br><span class="hljs-comment"># 设置MySQL服务器的默认存储引擎</span><br><span class="hljs-attr">default-storage-engine</span>=InnoDB<br><br><span class="hljs-comment"># 设置MySQL服务器的最大连接数</span><br><span class="hljs-attr">max_connections</span>=<span class="hljs-number">100</span><br><br><span class="hljs-comment"># 设置MySQL服务器的查询缓存大小</span><br><span class="hljs-comment"># query_cache_size=64M</span><br><br><span class="hljs-section">[client]</span><br><span class="hljs-comment"># 设置MySQL客户端连接服务器时的默认字符集</span><br><span class="hljs-attr">default-character-set</span>=utf8<br><br></code></pre></td></tr></table></figure><p>my.cnf配置详情参见<a href="https://developer.aliyun.com/article/822935">my.cnf配置</a><br></p><h3 id="配置init-sql"><a href="#配置init-sql" class="headerlink" title="配置init.sql"></a>配置init.sql</h3><p>init.sql用来初始化数据库。<br><br>实例代码如下<br></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span><br><span class="hljs-comment">/*!32312 IF NOT EXISTS*/</span><br>`<span class="hljs-number">123</span>`<br><span class="hljs-comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;<br><br>USE `<span class="hljs-number">123</span>`;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Navicat Premium Data Transfer</span><br><span class="hljs-comment">Source Server         : gin</span><br><span class="hljs-comment">Source Server Type    : MySQL</span><br><span class="hljs-comment">Source Server Version : 80031</span><br><span class="hljs-comment">Source Host           : localhost:3306</span><br><span class="hljs-comment">Source Schema         : 123</span><br><span class="hljs-comment">Target Server Type    : MySQL</span><br><span class="hljs-comment">Target Server Version : 80031</span><br><span class="hljs-comment">File Encoding         : 65001</span><br><span class="hljs-comment">Date: 26/03/2024 21:22:50</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">SET NAMES</span> utf8mb4;<br><br><span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-comment">-- Table structure for tb_browse_pv</span><br><span class="hljs-comment">-- ----------------------------</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> `<span class="hljs-number">111</span>`;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-number">111</span>` (<br>    `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `license_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb3 <span class="hljs-keyword">COLLATE</span> utf8mb3_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `<span class="hljs-type">date</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `num` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `created_at` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>, `updated_at` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>, <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE = InnoDB AUTO_INCREMENT = <span class="hljs-number">165</span> <span class="hljs-keyword">DEFAULT</span> CHARSET = utf8mb3;<br></code></pre></td></tr></table></figure><p><code>CREATE DATABASE</code>创建数据库。<br><code>USE</code>使用该数据库。<br><code>SET NAMES utf8mb4;</code>表示使用utf8mb4字符集。<br></p><h3 id="编写DockerFile"><a href="#编写DockerFile" class="headerlink" title="编写DockerFile"></a>编写DockerFile</h3><p>编写DockerFile如下<br></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> dockerproxy.cn/mysql:latest<br><br><span class="hljs-keyword">ENV</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">12345678</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./shell/mysql/my.cnf /etc/mysql/my.cnf</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./shell/mysql/init.sql /docker-entrypoint-initdb.d/</span><br></code></pre></td></tr></table></figure><p><code>FROM dockerproxy.cn/mysql:latest</code>表示使用镜像dockerproxy.cn&#x2F;mysql:latest<br><br><code>ENV MYSQL_ROOT_PASSWORD=12345678</code>设置mysql密码为12345678<br><br><code>COPY ./shell/mysql/my.cnf /etc/mysql/my.cnf</code>将当前目录下的shell&#x2F;mysql&#x2F;my.cnf复制到容器的&#x2F;etc&#x2F;mysql&#x2F;my.cnf<br><br><code>COPY ./shell/mysql/init.sql /docker-entrypoint-initdb.d/</code>将init.sql复制到&#x2F;docker-entrypoint-initdb.d&#x2F;用来初始化数据库<br><br>现在我们已经可以构建mysql容器了，但是数据库一定是给应用程序使用的，所以我们要将mysql容器和程序放在一个network里。</p><h3 id="构建network"><a href="#构建network" class="headerlink" title="构建network"></a>构建network</h3><p>使用如下命令构建network<br><br><code>docker network create my_network</code></p><h3 id="构建容器"><a href="#构建容器" class="headerlink" title="构建容器"></a>构建容器</h3><p>首先使用DockerFile构建镜像<br><br>命令如下<br><br><code>dokcer build -t [镜像名:tag] -f /path/to/DockerFile .</code><br><br>-t是指定构建的镜像的名称和tag，-f指定DokcerFile的路径，.则是指定当前目录为构建的上下文。<br><br>构建完镜像就要构建容器了<br><br>使用如下命令构建容器<br><br><code>docker run -d -p 3307:3306 --name my_mysql --network=my_network [使用的镜像名:tag]</code><br><br><code>-d</code>是指定容器在后台运行<br><br><code>-p</code>是指定端口映射，比如<code>-p 3307:3306</code>指将容器的3306端口映射到本地的3307端口，可以通过访问本地的3307端口获得mysql服务。<br><br><code>--name</code>指定容器名<br><br><code>--network</code>指定网络名<br><br>容器就run起来了，可以使用命令查看容器是否运行起来了<br><br><code>docker ps</code><br><br>结果应该是有如下输出。<br><br><img src="/2024/11/06/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/1.png" alt="image1"><br></p><h2 id="mysql备份与恢复"><a href="#mysql备份与恢复" class="headerlink" title="mysql备份与恢复"></a>mysql备份与恢复</h2><p>在应用程序中如果数据库不小心被删除了或损坏会让我们前功尽弃，所以提前备份显得十分重要！</p><h3 id="mysql备份"><a href="#mysql备份" class="headerlink" title="mysql备份"></a>mysql备份</h3><p>要备份容器中的数据，可以使用如下命令<br></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#进入容器</span><br>sudo docker exec -it my_mysql <span class="hljs-regexp">/bin/</span>bash<br><br><span class="hljs-comment">#生成备份文件</span><br><span class="hljs-comment">#-uroot指以root用户登录 -p密码登录 +%F指定日期</span><br>mysqldump -uroot -p --all-databases &gt; emp_`date +%F`.sql<br><br><span class="hljs-comment">#退出容器</span><br><span class="hljs-keyword">exit</span>或者ctrl + D<br><br><span class="hljs-comment">#将备份文件复制到本地文件夹中</span><br>sudo docker cp my_mysql:emp_.sql <span class="hljs-regexp">/var/</span>backup/<br></code></pre></td></tr></table></figure><h3 id="mysql恢复"><a href="#mysql恢复" class="headerlink" title="mysql恢复"></a>mysql恢复</h3><h4 id="容器中还原"><a href="#容器中还原" class="headerlink" title="容器中还原"></a>容器中还原</h4><p>将生成的.sql文件复制到init.sql中，重新构建mysql镜像即可。</p><h4 id="非容器还原"><a href="#非容器还原" class="headerlink" title="非容器还原"></a>非容器还原</h4><p>进入直接用<code>source /path/to/.sql</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-Learning</title>
    <link href="/2024/10/25/Docker-Learning/"/>
    <url>/2024/10/25/Docker-Learning/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-Learning"><a href="#Docker-Learning" class="headerlink" title="Docker-Learning"></a>Docker-Learning</h1><p>这篇文章记录了学习的Docker知识。</p><h2 id="Docker有用小命令"><a href="#Docker有用小命令" class="headerlink" title="Docker有用小命令"></a>Docker有用小命令</h2><p><code>docker ps</code>列出运行中的进程<br><br><code>docker logs 容器ID</code>打印容器日志<br></p><h2 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h2><ol><li>Docker镜像：用于创建Docker容器的模板，可以理解为一个静态定义的操作系统。</li><li>Docker容器：Docker镜像运行的一个实例。</li><li>Docker客户端：与Docker守护进程通信。</li><li>Docker Host：用来执行Docker守护进程和容器。</li><li>Docker Registry：用来保存镜像，代码仓库</li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h3><p>使用官方脚本自动安装<br></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">curl -fsSL https:<span class="hljs-comment">//test.docker.com -o test-docker.sh</span><br>sudo <span class="hljs-keyword">sh</span> <span class="hljs-keyword">test</span>-docker.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>详情参考<a href="https://www.runoob.com/docker/windows-docker-install.html">Windows Docker安装</a></p><h2 id="在Docker中运行应用程序"><a href="#在Docker中运行应用程序" class="headerlink" title="在Docker中运行应用程序"></a>在Docker中运行应用程序</h2><p>以hello world为例<br></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker run <span class="hljs-symbol">ubuntu:</span><span class="hljs-number">15.10</span> /bin/echo <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-title class_">Hello</span> world<br></code></pre></td></tr></table></figure><p>或者执行以下命令进入Docker容器<br></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker run -i -t <span class="hljs-symbol">ubuntu:</span><span class="hljs-number">15.10</span> /bin/bash<br>root<span class="hljs-variable">@0123ce188bd8</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>使用<code>docker run -d</code>将容器挂在后台运行</p><h2 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h2><p>载入镜像<br><br><code>docker pull ubuntu</code><br><br>查看所有容器<br><br><code>docker ps - a</code><br><br>启动一个已停止容器<br><br><code>docker start 容器ID</code><br><br>停止一个容器<br><br><code>docker stop 容器ID</code><br><br>重启容器<br><br><code> docker restart &lt;容器 ID&gt;</code><br><br>进入容器<br><br><code>docker exec -it &lt;容器ID&gt; /bin/bash</code><br><br>导出导入容器<br></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">docker</span> ex<span class="hljs-keyword">port</span> 1e560fca3906 &gt; ubuntu.tar<br><span class="hljs-title">docker</span> <span class="hljs-keyword">import</span> - test/ubuntu:v1<br></code></pre></td></tr></table></figure><p>删除容器<br><br><code>docker rm -f &lt;容器ID&gt;</code><br><br>清理掉所有处于终止状态的容器<br><br><code>docker container prune</code><br><br>运行一个web应用<br></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># docker pull training/webapp  # 载入镜像</span><br>runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># docker run -d -P training/webapp python app.py</span><br><br></code></pre></td></tr></table></figure><ul><li>-P将容器内部使用的网络端口映射到我们使用的主机上。</li></ul><h1 id="DockerFile构建容器"><a href="#DockerFile构建容器" class="headerlink" title="DockerFile构建容器"></a>DockerFile构建容器</h1><p>以下介绍如何使用DockerFile构建镜像</p><h2 id="编写DockerFile"><a href="#编写DockerFile" class="headerlink" title="编写DockerFile"></a>编写DockerFile</h2><p>多阶段构建可以让最终的镜像大小变小<br></p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> golang:1.19 AS builder<br><br><span class="hljs-comment"># 设置必要的环境变量</span><br>ENV <span class="hljs-attribute">GO111MODULE</span>=on \<br>    <span class="hljs-attribute">GOPROXY</span>=https://proxy.golang.org,direct \<br>    <span class="hljs-attribute">CGO_ENABLED</span>=0 \<br>    <span class="hljs-attribute">GOOS</span>=linux \<br>    <span class="hljs-attribute">GOARCH</span>=amd64<br><br><span class="hljs-comment"># 复制Go应用程序代码并构建CLI</span><br>COPY . /ToolCollection<br>WORKDIR /ToolCollection<br><span class="hljs-built_in">RUN</span> go build -o ./bin/cli ./cmd/cli/main.go<br></code></pre></td></tr></table></figure><p>第一阶段构建Go环境，获得编译好的GO应用程序<br></p><ol><li>首先拉取golang:1.19，as builder是给镜像取名，方便后面引用</li><li>设置Go环境变量</li><li>将代码复制到容器中，制定工作目录，并且编译Go程序</li></ol><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 第二阶段：创建包含CUDA和Python 3.8的最终镜像</span><br><span class="hljs-keyword">FROM</span> nvidia/cuda:<span class="hljs-number">11.8</span>.<span class="hljs-number">0</span>-devel-ubuntu20.<span class="hljs-number">04</span> <br><br><span class="hljs-comment"># 安装 Python 3.9 和 pip</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3.9 python3-pip</span><br><br><span class="hljs-comment"># 创建符号链接以便使用 python3 命令</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">ln</span> -s /usr/bin/python3.9 /usr/bin/python3</span><br><br><span class="hljs-comment"># 安装 PyTorch 和其他依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install --no-cache-dir \</span><br><span class="language-bash">    flet \</span><br><span class="language-bash">    torch==2.0.1+cu118 \</span><br><span class="language-bash">    torchvision==0.15.0+cu118 \</span><br><span class="language-bash">    torchaudio==2.0.2 \</span><br><span class="language-bash">    librosa \</span><br><span class="language-bash">    numpy \</span><br><span class="language-bash">    wave \</span><br><span class="language-bash">    -f https://download.pytorch.org/whl/torch_stable.html</span><br><br><span class="hljs-comment"># 复制Go应用程序二进制文件</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /ToolCollection /ToolCollection</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /ToolCollection/bin/cli /usr/local/bin/cli</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /ToolCollection</span><br><br><br><span class="hljs-comment"># 定义容器启动命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;cli&quot;</span> ]</span><br></code></pre></td></tr></table></figure><p>该阶段从上一个阶段抽取构建好的应用程序，并且配置python、cuda环境，用以推理<br></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BIRD数据集使用教程</title>
    <link href="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h2><p>在<code>https://bird-bench.github.io/</code>中下载<code>dev set</code>并解压。</p><h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>创建项目文件夹，如<br><br><code>mkdir xxx </code><br><br>进入项目目录并执行git init初始化<br><br><code> git init</code><br>和仓库进行关联<br><br><code>git remote add -f origin https://github.com/AlibabaResearch/DAMO-ConvAI.git</code><br><br>开启稀疏检出<br><br><code>git config core.sparsecheckout true</code><br><br>sparse-checkout文件里写入”bird”<br><br><code> echo &quot;bird&quot; &gt;&gt; .git/info/sparse-checkout</code><br><br>拉取远程仓库<br><br><code>git pull origin main</code><br>以上命令如报错可尝试用sudo</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>将text-to-sql生成的sql语句以json格式放入<code>./llm/exp_result/turbo_output_kg/predict_dev.json</code>(如果为without knowledge则放<code>./llm/exp_result/turbo_output/predict_dev.json</code>)格式要与该json文件中给的例子相同，如下图所示，使用<code>&#39;\t----- bird -----\t&#39;</code>分隔sql语句与数据库名称。<br><br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/3.png" alt="alt text"><br><br>将解压的<code>dev set</code>中的<code>dev.json</code>、<code>dev_gold.sql</code>、<code>dev_databases</code>存到<code>./llm/data/</code>目录下<br><br>安装依赖<br><code>pip install func_timeout</code></p><h2 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h2><p>因为不需要ves，将<code>./llm/run/run_evaluation.sh</code>脚本中关于ves的部分注释掉即可。</p><h2 id="启动EX-Evaluation"><a href="#启动EX-Evaluation" class="headerlink" title="启动EX Evaluation"></a>启动EX Evaluation</h2><p>在<code>./llm</code>目录下运行<code>sh ./run/run_evaluation.sh</code>即可。<br>得到结果如下图所示。<br><br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/2.png" alt="alt text"></p><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>从如下代码可以看出计算逻辑,是以生成的sql语句和真实sql语句执行结果的集合相等的概率作为指标<br><br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/5.png" alt="alt text"><br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/6.png" alt="alt text"></p><h1 id="测试gpt的EX执行准确率"><a href="#测试gpt的EX执行准确率" class="headerlink" title="测试gpt的EX执行准确率"></a>测试gpt的EX执行准确率</h1><h2 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h2><p>参照<code>BIRD使用教程</code>下载<code>dev set</code>并将解压的东西放到相应的地方</p><h2 id="获取api-key"><a href="#获取api-key" class="headerlink" title="获取api key"></a>获取api key</h2><p>在<code>https://platform.openai.com/api-keys</code>中创建自己的api key并将其复制到<code>./llm/run/run_gpt.sh</code>的<code>YOUR_API_KEY</code>中</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><code>pip install openai==0.28 backoff pandas sqlparse tqdm</code><br><br>在<code>./run/run_gpt.sh</code>中将启动时传入的模型参数改为engine2,即为<code>text-davinci-003</code>(要测gpt-3.5-turbo则将engine选为engine3)<br><br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/8.png" alt="alt text"><br><br>挂梯子，如果是linux要手动配置代理,详情参考<a href>linux服务器clash教程</a></p><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><p>切换到目录<code>./llm</code>执行<code>sh ./run/run_gpt.sh</code>即可生成预测的sql语句。<br><br>执行<code>sh ./run/run_evaluation.sh</code>即可获得text-davinci-003模型 text-to-sql的EX准确率如下图所示。<br><br>text-davinci-003<br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/7.png" alt="alt text"><br>获得gpt-3.5-turbo的EX准确率如下<br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/9.png" alt="alt text"></p><h1 id="对照"><a href="#对照" class="headerlink" title="对照"></a>对照</h1><p>与论文<code>Understanding the Effects of Noise in Text-to-SQL: An Examination of the BIRD-Bench Benchmark</code>中使用不同训练方法得到的准确率作对比。<br><br><img src="/2024/10/24/BIRD%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/10.png" alt="alt text"><br><br>可以发现准确率比较接近。可以看出text-davinci-003在text-to-sql方面准确率更高。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BIRD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux服务器上的Go环境搭建</title>
    <link href="/2024/10/24/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Go%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/10/24/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Go%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Go环境搭建"><a href="#Go环境搭建" class="headerlink" title="Go环境搭建"></a>Go环境搭建</h1><p>本篇文章写了linux下go语言环境的安装配置以及如何写一个简单的go程序。</p><h2 id="下载go压缩包"><a href="#下载go压缩包" class="headerlink" title="下载go压缩包"></a>下载go压缩包</h2><p>查看架构<br><br><code>uname -i</code><br><br>在<a href="https://golang.google.cn/dl/">go官方网站</a>下载go压缩包。如果是<code>x86_64</code>则选择<code>goxxx.linux-amd64.tar.gz</code>其余的根据架构选择对应的版本。本文以<em>go1.23.2.linux-amd64.tar.gz</em>为例<br><br>将压缩包复制到&#x2F;usr&#x2F;local&#x2F;目录下,或者可以用以下代码直接下载到指定目录。<br></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/usr/</span>local<br>wget https:<span class="hljs-regexp">//g</span>olang.google.cn<span class="hljs-regexp">/dl/g</span>o1.<span class="hljs-number">23.2</span>.linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>将压缩包解压缩<br><br><code>tar -zxvf go1.23.2.linux-amd64.tar.gz</code></p><h2 id="进行go环境的配置"><a href="#进行go环境的配置" class="headerlink" title="进行go环境的配置"></a>进行go环境的配置</h2><h3 id="GOROOT和PATH"><a href="#GOROOT和PATH" class="headerlink" title="GOROOT和PATH"></a>GOROOT和PATH</h3><p>编辑<code>~/.profile</code>文件，在末尾加上<br></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOROOT</span>=/usr/local/go<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$GOROOT/bin<br></code></pre></td></tr></table></figure><p>GOROOT是安装go语言包的地方，也就是&#x2F;usr&#x2F;local&#x2F;go。PATH则是go可执行程序所在的地方。1.14版本后就不用在GOPATH下放置代码了，直接用默认的即可。<br>保存更改<br><br><code>source ~/.profile</code><br><br>验证go安装并配置成功<br><br><code>go version</code><br><br>出现如下字样则安装成功<br><br><code>go version go1.23.2 linux/amd64</code></p><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>GOPROXY是下载包的代理，更换GOPROXY为国内网站：<code>https://goproxy.cn</code><br><br><code>go env -w GOPROXY=https://goproxy.cn,direct</code></p><h2 id="第一个go程序"><a href="#第一个go程序" class="headerlink" title="第一个go程序"></a>第一个go程序</h2><p>创建一个目录<code>myDemo</code><br><br>在目录下<code>go mod init myDemo(项目名称)</code><br><br>编写go程序，在项目根目录执行<br><br><code>go run main.go</code>或者<code>go build -o 可执行文件名</code>即可</p><h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h2><p>在windows上进行开发linux上的程序，可以使用跨平台编译。设置环境变量。<br><br>使用cmd执行<br></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> CGO_ENABLED=0  <span class="hljs-comment">// 禁用CGO</span><br><span class="hljs-keyword">SET</span> <span class="hljs-comment">GOOS=linux</span>  // 目标平台是<span class="hljs-comment">linux</span><br><span class="hljs-keyword">SET</span> <span class="hljs-comment">GOARCH=amd64</span>  // 目标处理器架构是<span class="hljs-comment">amd64</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建个人网页教程</title>
    <link href="/2024/10/16/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E6%95%99%E7%A8%8B/"/>
    <url>/2024/10/16/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建个人网页"><a href="#搭建个人网页" class="headerlink" title="搭建个人网页"></a>搭建个人网页</h1><p>这篇文章是关于如何简单搭建自己的网页</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>可以租一个服务器,比如阿里云服务器、腾讯云服务器等等。可以参考<a href="https://developer.aliyun.com/article/1324081">服务器租用教程</a><br><br>租用好服务器就可以通过控制台直接连接了。</p><h2 id="Nginx安装与配置"><a href="#Nginx安装与配置" class="headerlink" title="Nginx安装与配置"></a>Nginx安装与配置</h2><h3 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h3><p>首先用如下代码完成nginx的安装<br><br><code>sudo apt update</code><br><br><code> sudo apt install nginx</code><br><br>用以下代码验证安装成功<br><br><code> nginx -v</code><br></p><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p>使用vim打开Nginx配置文件。<br><br><code> sudo vim /etc/nginx/nginx.conf</code><br><br>在http块中增加如下内容<br><br><img src="/2024/10/16/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E6%95%99%E7%A8%8B/1.png" alt="1"><br><br>listen表示监听的端口。server_name表示服务器的ip地址或域名，填127.0.0.1即可。root则是存放网页文件的根目录，一般设置为&#x2F;var&#x2F;www&#x2F;html。location 指定了请求的 URL 匹配规则，这里我们将所有的请求都指向静态文件，并返回404错误。<br><br>测试配置是否有效<br><br><code> sudo nginx -t</code><br><br>如果配置文件没有错误，应该会看到以下输出<br><br><code> nginx: configuration file /etc/nginx/nginx.conf test is successful</code><br><br>最后，使用以下命令重启 Nginx 以使新的配置生效：<br><code> sudo systemlctl restart nginx</code><br></p><h2 id="网页文件"><a href="#网页文件" class="headerlink" title="网页文件"></a>网页文件</h2><p>将网页文件全部打包到&#x2F;var&#x2F;www&#x2F;html目录下。<br><br>访问ip:port即可访问页面。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Graph-Corloring</title>
    <link href="/2024/10/13/Graph-Corloring/"/>
    <url>/2024/10/13/Graph-Corloring/</url>
    
    <content type="html"><![CDATA[<h1 id="Graph-Corloring"><a href="#Graph-Corloring" class="headerlink" title="Graph-Corloring"></a>Graph-Corloring</h1><h2 id="problem-formulation"><a href="#problem-formulation" class="headerlink" title="problem formulation"></a>problem formulation</h2><p>给定一个图G（V,E），将G划分为K个子集，每个子集中的节点都互不邻接。</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建流程（github+hexo）</title>
    <link href="/2024/10/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88github-hexo%EF%BC%89/"/>
    <url>/2024/10/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88github-hexo%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="个人博客搭建流程（github-hexo）"><a href="#个人博客搭建流程（github-hexo）" class="headerlink" title="个人博客搭建流程（github+hexo）"></a>个人博客搭建流程（github+hexo）</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>git是一个开源的分布式版本控制系统，使用git可以让你在进行团队或个人开发的时候，更好的管理不同版本的代码。<br><br>详情参照<a href="https://blog.csdn.net/yaorongke/article/details/119085413">git安装</a></p><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>node.js是一个js的运行环境<br><br>详情参考<a href="https://blog.csdn.net/yaorongke/article/details/119084295">nodejs安装</a></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>hexo是一个静态博客网站生成器，具有博客在线预览，为博客生成静态文件，将静态文件打包到github上的功能，非常便利。<br><br>安装hexo<br><br><code>npm install -g hexo-cli</code><br><br>创建一个项目并初始化，例如<br><br><code> hexo init blog</code><br><br><code> cd blog</code><br><br><code> npm install</code><br></p><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p>如下修改 Hexo 博客目录中的 _config.yml，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。<br><br><code>post_asset_folder: true</code><br><br>执行如下命令创建一篇新文章，比如“个人博客搭建流程”<br><br><code>hexo new post 个人博客搭建流程</code><br><br>在该路径下会有一个.md文件，对文章内容修改只需要在.md文件修改即可。<br><br><img src="/2024/10/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%EF%BC%88github-hexo%EF%BC%89/1.png" alt="1"><br><br>修改途中可以用如下代码在<a href="http://localhost:4000/">本地</a>预览博客<br><br><code>hexo g</code><br><br><code>hexo s</code></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>在github中创建一个名为<code>username.github.io</code>的仓库。<br><br>将博客目录与博客仓库默认分支远程关联。<br><br><code>git remote add origin https://github.com/username/repository.git</code><br><br><code>git checkout master</code><br><br><code>git push -u origin master</code><br></p><h3 id="部署博客网页"><a href="#部署博客网页" class="headerlink" title="部署博客网页"></a>部署博客网页</h3><p><code>hexo g</code><br><br><code>hexo deploy</code><br></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CV</title>
    <link href="/2024/10/11/CV/"/>
    <url>/2024/10/11/CV/</url>
    
    <content type="html"><![CDATA[<h2 id="Work-Experience"><a href="#Work-Experience" class="headerlink" title="Work Experience"></a>Work Experience</h2><h3 id="AntHap-蚁触科技-后端开发实习生"><a href="#AntHap-蚁触科技-后端开发实习生" class="headerlink" title="AntHap(蚁触科技)后端开发实习生"></a>AntHap(蚁触科技)后端开发实习生</h3><ul><li>FancyHaptic后台管理系统开发。使用ginskeleton、jwt等技术进行后端业务开发。</li><li>ToolCollection微服务架构开发。使用rabbitmq、ginskeleton等开发微服务架构。</li></ul><h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><ul><li>Undergraduate : HUST,CSE</li><li>Master : HUST,CS</li><li>Lab : 人工智能与优化研究所EDA与工业优化团队</li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><h3 id="面向物联网设备的加密代理装置设计"><a href="#面向物联网设备的加密代理装置设计" class="headerlink" title="面向物联网设备的加密代理装置设计"></a>面向物联网设备的加密代理装置设计</h3><ul><li>核心技术: TCP&#x2F;UDP通信协议编程、计算机网络及操作系统基础知识、Golang、密码算法基础知识<br>协议设计者、加密代理装置编程者</li><li>项目描述:</li><li>项目主要包括加密模块、传输模块。</li><li>加密模块使用国密算法sm2、sm3、sm4等完成，完成了用户身份鉴定、完整性校验、机密性保护等功能。</li><li>传输模块中基于udp协议设计了用于物联网设备的通信协议，使用了并发锁，超时重传等机制保证数据可靠传输，使用</li><li>putty模拟链路高负载情况下丢包率低于1%。</li><li>项目地址：<a href="https://github.com/qjz66/cypher-agent">https://github.com/qjz66/cypher-agent</a></li></ul><h3 id="RumorBuzz：基于多领域自适应学习的谣言检测及交互平台"><a href="#RumorBuzz：基于多领域自适应学习的谣言检测及交互平台" class="headerlink" title="RumorBuzz：基于多领域自适应学习的谣言检测及交互平台"></a>RumorBuzz：基于多领域自适应学习的谣言检测及交互平台</h3><p>后端负责人</p><ul><li>项目架构: MVC架构</li><li>核心技术: gin、gorm、MySQL、jwt、Redis</li><li>项目描述: 前后端分离项目。根据项目需求与前端协商接口文档并建模使⽤ Gin、Gorm 等框架构建 RESTful API 服务。使</li><li>用JWT认证提供认证模块。使用redis作为缓存数据库，实现热榜、点赞等功能。</li><li>项目地址：<a href="https://github.com/qjz66/ISWC">https://github.com/qjz66/ISWC</a></li></ul><h3 id="MIT-6-824-分布式系统"><a href="#MIT-6-824-分布式系统" class="headerlink" title="MIT 6.824 分布式系统"></a>MIT 6.824 分布式系统</h3><ul><li>编写核心组件、学习分布式知识</li><li>核心技术：MapReduce、Raft 、kv存储</li><li>项目描述：</li><li>实现单机多进程版本的并行计算 MapReduce，使得通过 MapReduce 建模的问题可以大幅提高并行处理性能</li><li>实现支持选举、日志复制等机制的 Raft 共识算法，并对日志回退进行优化，减少不必要 RPC 请求</li><li>底层使用自实现 Raft 构建高可用 KV 存储服务，集群节点只要超过⼀半正常服务，便可对外提供服务，大幅提高集群可用性</li></ul><h2 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h2><ul><li>熟练掌握各种初级数据结构与算法。包括但不限于各种二叉树、队列、堆、栈、哈希表、链表、并查集、排序算法、贪心、递归、动态规划</li><li>扎实的编程基础：熟悉面向对象的编程思想、了解并发机制，熟练使用C++、C、Golang。</li><li>熟练使用各种中间件。例如rabbitmq、redis、nginx等等。</li><li>能熟练地使用各种开发工具。比如使用docker进行软件的打包与部署、使用git进行版本控制与协作开发。</li><li>熟练掌握计算机网络知识及应用，熟悉TCP&#x2F;UDP、HTTP&#x2F;HTTPS等协议，熟悉Socket编程。</li></ul><h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><ul><li><a href="https://github.com/qjz66">Github</a></li><li><a href="2199921383@qq.com">Email</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>个人介绍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
